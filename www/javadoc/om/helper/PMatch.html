<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_13) on Tue Nov 10 11:01:25 GMT 2009 -->
<TITLE>
PMatch
</TITLE>

<META NAME="date" CONTENT="2009-11-10">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="PMatch";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../om/helper/NullQuestion.html" title="class in om.helper"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../om/helper/QEngineConfig.html" title="interface in om.helper"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?om/helper/PMatch.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PMatch.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
om.helper</FONT>
<BR>
Class PMatch</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>om.helper.PMatch</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>PMatch</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<p>The OpenMark <code>PMatch</code> (pattern match) class is used to test
 if a student response string matches a specified response pattern.</p>
 
 <p>PMatch extends the older OpenMark Match routine
 <ul>
 <li>to allow misspellings of a single character or two characters for longer words</li>
 <li>to support the proximity of words</li>
 </ul>
 </p>

 <p>Changes since OpenMark 1.7.2<br>
 <ul>
 <li>Experience has shown that the proximity function delivers much of
 what was achieved by splitting the response into sentences before matching.
 Consequently PMatch has been refined such that it now considers the whole
 response but the proximity function only applies to words in the same
 sentence.</li>
 <li>Word groups are now available in OR sequences.</li>
 <li>character transposition has been added to the misspellings that are catered for</li>
 <li>the misspellings rules ignore wildcards when calculating the length of the
 pattern to be matched.</li>
 </ul>
 </p>
 <p>Changes from Match()</p>
 <p><b>Match users should beware</b> that:
 <ul>
 <li>In PMatch the response is set and then matched against multiple patterns
 c.f. Match where the pattern is set and then matched against a response.</li>
 <li>In PMatch the word OR symbol is '|'. This replaces the $ used by Match.</li>
 </ul>
 </p>
 <p>PMatch works on the basis that you have a student response which you wish
 to match against any number of response matching patterns.</p>
 
 <p>Create a PMatch object with the student response as a parameter<br/>
 <code>PMatch m = new PMatch(resp);</code><br/>
 where resp is a String holding the student response.</p>
 
 <p>Or create a PMatch object with an empty student response<br/>
 <code>PMatch m = new PMatch("");</code><br/>
 then set the student response using<br>
 <code>m.setResponse(resp);</code></p>
 
 <p>Then carry out repeated response matching tests using the match method.
 Match returns true if the student response contains the pattern.<br/>
 <code>if (m.match("mow", "tom|dick|harry")) { }</code></p>
 
 <p>The match method takes two parameters
 <ul>
 <li>the matching options: <code>mow</code></li>
 <li>the words to be matched: <code>tom|dick|harry</code></li>
 </ul>
 </p>
 
 <p>The basic unit that PMatch operates on is the word, where a word is defined
 as a sequence of characters between spaces.</p>
 
 <p>The response is treated as a whole with the exception that words that
 are required to be in proximity must also be in the same sentence.</p>
 
 <p>PMatch matches what it is given. Whether case does or does not matter is
 left to the author to decide and to handle using normal Java methods. Typically
 if case does not matter the pattern match is specified in lower case and the
 response is transformed to lower case using the standard Java method
 toLowerCase() before PMatch is called.</p>
 
 <p>'comma', 'semi-colon' and 'colon' have no significance to PMatch. If authors
 wish to use any of these as a delimiter in a response they should replace it
 with 'space' using the standard Java method replace() before calling PMatch.</p>
 
 <p>The matching options are:
 <table border="1">
 <tr><th>Matching option</th><th>Symbol</th><th>Description</th></tr>
 <tr><td>allowExtraChars</td><td>c</td><td>Extra characters can be anywhere
 within the word. Authors are expected to omit allowExtraChars when using the
 misspelling options below.</td></tr>
 <tr><td>allowAnyWordOrder</td><td>o</td><td>Where multiple words are to be
 matched they can be in any order.</td></tr>
 <tr><td>allowExtraWords</td><td>w</td><td>Extra words beyond those being
 searched for are accepted.</td></tr>
 <tr><td>misspelling: allowReplaceChar</td><td>mr</td><td>Will match a word
 where one character is different to those specified in the pattern. The pattern
 word must be 4 characters or greater, excluding wildcards, for replacement
 to kick in. Authors are
 expected to omit allowExtraChars when using this option.</td></tr>
 <tr><td>misspelling: allowTransposeTwoChars</td><td>mt</td><td>Will match a word
 where two characters are transposed. The pattern
 word must be 4 characters or greater, excluding wildcards, for transposition
 to kick in. Authors are
 expected to omit allowExtraChars when using this option.</td></tr>
 <tr><td>misspelling: allowExtraChar</td><td>mx</td><td>Will match a word where
 one character is extra to those specified in the pattern. The pattern word must
 be 3 characters or greater, excluding wildcards, for extra to kick in.
 Authors are expected to omit
 allowExtraChars when using this option.</td></tr>
 <tr><td>misspelling: allowFewerChar</td><td>mf</td><td>Will match a word where
 one character is missing from those specified in the pattern. The pattern word
 must be 4 characters or greater, excluding wildcards, for fewer to kick in. Without this 'no' would
 be reduced to just matching  'n' or 'o'. Authors are expected to omit
 allowExtraChars when using this option.</td></tr>
 <tr><td>misspelling</td><td>m</td><td>This combines the four ways of
 misspelling a word described above i.e. m is equivalent to mxfrt. Authors are
 expected to omit allowExtraChars when using this option.</td></tr>
 <tr><td>misspellings</td><td>m2</td><td>Allows two misspellings, as defined by
 option 'm', in pattern words of 8 characters or more, excluding wildcards. Authors are expected to omit
 allowExtraChars when using this option.</td></tr>
 <tr><td>allowProximityOf0</td><td>p0</td><td>No words, or full stops, are allowed in between
 any words specified in the proximity sequence.</td></tr>
 <tr><td>allowProximityOf1</td><td>p1</td><td>One word is allowed in between any
 two words specified in the proximity sequence. The words must not span sentences.</td></tr>
 <tr><td>allowProximityOf2</td><td>p2</td><td>(Default value) Two words are
 allowed in between any two words specified in the proximity sequence. The words
 must not span sentences.</td></tr>
 <tr><td>allowProximityOf3</td><td>p3</td><td>Three words are allowed in between
 any two words specified in the proximity sequence. The words must not span sentences.</td></tr>
 <tr><td>allowProximityOf4</td><td>p4</td><td>Four words are allowed in between
 any two words specified in the proximity sequence. The words must not span sentences.</td></tr>
 </table></p>
 
 <p>Within a word 'special characters' provide more localised control of the
 patterns:
 <table border="1">
 <tr><th>Special character</th><th>Symbol</th><th>Description</th></tr>
 <tr><td>Word AND</td><td>space</td><td>'space' delimits words and acts as the
 logical AND.</td></tr>
 <tr><td>Word OR</td><td>|</td><td>| between words indicates that either word
 will be matched. | delimits words and acts as the logical OR.</td></tr>
 <tr><td>Proximity control</td><td>_</td><td>Words must be in the order given
 and with no more than n (where n is 0 - 4) intervening words. All words under
 the proximity control must be in the same sentence. _ delimits words
 and also acts as logical 'AND'. </td></tr>
 <tr><td>Word groups</td><td>[]</td><td>[] enables
 multiple words to be accepted as an alternative to other single words in
 OR lists.
 [] may not be nested. Single words may be OR'd inside [].
 Where a word group is preceded or followed by the
 proximity control the word group is governed by the
 proximity control rule that the words must be in the order given.</td></tr>
 <tr><td>Single character wildcard</td><td>#</td><td>Matches any single
 character.</td></tr>
 <tr><td>Multiple character wildcard</td><td>&</td><td>Matches any sequence of
 characters including none.</td></tr>
 </table></p>
 
 <p>Examples:
 <table border="1">
 <tr><th>Student response</th><th>Matching options</th><th>Pattern match</th><th>
 match method return</th></tr>
 <tr><td>tom dick harry</td><td>empty</td><td>tom dick harry</td><td>true.
 This is the exact match.</td></tr>
 <tr><td>thomas</td><td>c</td><td>tom</td><td>true. Extra characters are allowed
 anywhere within the word.</td></tr>
 <tr><td>tom, dick and harry</td><td>w</td><td>dick</td><td>true. Extra words
 are allowed anywhere within the sentence.</td></tr>
 <tr><td>harry dick tom</td><td>o</td><td>tom dick harry</td><td>true. Any order
 of words is allowed.</td></tr>
 <tr><td>rick</td><td>m</td><td>dick</td><td>true. One character in the word can
 differ.</td></tr>
 <tr><td>rick and harry and tom</td><td>mow</td><td>tom dick harry</td>
 <td>true.</td></tr>
 <tr><td>dick and harry and thomas</td><td>cow</td><td>tom dick harry</td>
 <td>true.</td></tr>
 <tr><td>arthur, harry and sid</td><td>mow</td><td>tom|dick|harry</td>
 <td>true. Any of tom or dick or harry will be matched.</td></tr>
 <tr><td>tom, harry and sid</td><td>mow</td><td>tom|dick harry|sid</td>
 <td>true. The pattern requires either tom or dick AND harry or sid. Note that
 'tom,' is only allowed because m allows the extra character, the comma, in
 'tom,'.</td></tr>
 <tr><td>tom was mesmerised by maud</td><td>mow</td><td>[tom maud]|[sid jane]</td>
 <td>true. The pattern requires either (tom and maud) or (sid and jane).
 </td></tr>
 <tr><td>rick</td><td>empty</td><td>#ick</td><td>true. The first character can
 be anything.</td></tr>
 <tr><td>harold</td><td>empty</td><td>har&</td><td>true. Any sequence of
 characters can follow 'har'.</td></tr>
 <tr><td>tom married maud, sid married jane.</td><td>mow</td><td>tom_maud</td>
 <td>true. Only one word is between tom and maud.</td></tr>
 <tr><td>maud married tom, sid married jane.</td><td>mow</td><td>tom_maud</td>
 <td>false. The proximity control also specifies word order and over-rides the
 allowAnyWordOrder matching option.</td></tr>
 <tr><td>tom married maud, sid married jane.</td><td>mow</td><td>tom_jane</td>
 <td>false. Only two words are allowed between tom and jane.</td></tr>
 <tr><td>tom married maud</td><td>mow</td><td>tom|thomas marr& maud</td>
 <td>true.</td></tr>
 <tr><td>maud marries thomas</td><td>mow</td><td>tom|thomas marr& maud</td>
 <td>true.</td></tr>
 <tr><td>tom is to marry maud</td><td>mow</td><td>tom|thomas marr& maud</td>
 <td>true.</td></tr>
 <tr><td>tempratur</td><td>m2ow</td><td>temperature</td>
 <td>true. Two characters are missing.</td></tr>
 <tr><td>temporatur</td><td>m2ow</td><td>temperature</td><td>true. Two characters
 are incorrect; one has been replaced and one is missing.</td></tr>
 </table></p>
 
 <h2>History</h2>
 <p>The underlying structure of the response matching described here was developed
 in the Computer Based Learning Unit of Leeds University in the 1970s and was
 incorporated into Leeds Author Language. The basic unit of the word, the matching
 options of allowAnyChars, allowAnyWords, allowAnyOrder and the word OR feature
 all date back to Leeds Author Language.</p>
 
 <p>In 1976 the CALCHEM project which was hosted by the Computer Based Learning
 Unit, the Chemistry Department at Leeds University and the Computer Centre of
 Sheffield Polytechnic (now Sheffield Hallam University) produced a portable
 version of Leeds Author Language.</p>
 
 <p>A portable version for microcomputers was developed in 1982 by the Open
 University, the Midland Bank (as it then was; now Midland is part of HSBC) and
 Imperial College. The single and multiple character wildcards were added at this
 time.</p>
 
 <p>The misspelling, proximity and Word groups in 'or' lists additions
 were added as part of the Open University COLMSCT projects looking at
 free text response matching during 2006 - 2009.</p>
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../om/helper/PMatch.html#PMatch()">PMatch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an empty response object which will be filled later
 using setResponse().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../om/helper/PMatch.html#PMatch(java.lang.String)">PMatch</A></B>(java.lang.String&nbsp;response)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a response object via setResponse()</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../om/helper/PMatch.html#match(java.lang.String)">match</A></B>(java.lang.String&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../om/helper/PMatch.html#match(java.lang.String, java.lang.String)">match</A></B>(java.lang.String&nbsp;matchingOptions,
      java.lang.String&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match checks the response provided against an established pattern using the
 matching options and special characters specified
 
 match works on whole reply</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../om/helper/PMatch.html#setMatchingOptions(java.lang.String)">setMatchingOptions</A></B>(java.lang.String&nbsp;matchingOptions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../om/helper/PMatch.html#setPattern(java.lang.String)">setPattern</A></B>(java.lang.String&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the pattern that we want to test strings against.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../om/helper/PMatch.html#setResponse(java.lang.String)">setResponse</A></B>(java.lang.String&nbsp;response)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../om/helper/PMatch.html#splitAndMatch(java.lang.String)">splitAndMatch</A></B>(java.lang.String&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="PMatch(java.lang.String)"><!-- --></A><H3>
PMatch</H3>
<PRE>
public <B>PMatch</B>(java.lang.String&nbsp;response)</PRE>
<DL>
<DD>Constructs a response object via setResponse()
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - response</DL>
</DL>
<HR>

<A NAME="PMatch()"><!-- --></A><H3>
PMatch</H3>
<PRE>
public <B>PMatch</B>()</PRE>
<DL>
<DD>Constructs an empty response object which will be filled later
 using setResponse().
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setPattern(java.lang.String)"><!-- --></A><H3>
setPattern</H3>
<PRE>
public void <B>setPattern</B>(java.lang.String&nbsp;pattern)</PRE>
<DL>
<DD>Sets the pattern that we want to test strings against.
 The pattern is a set of one or more words (each word separated by a space).
 To get a match, all of the words in the pattern must match with a word
 in the string you are matching against. Extra control of the matching
 process can be achieved using the '&', '#' '|' and '_' characters. If you
 want to use these characters literally, precede them with the two
 backslash characters.
 <br>
 '&' means match any string (including empty). <br>
 '#' means match any character. <br>
 '|' match with the preceding OR the next word. <br>
 '[]' means treat the Word group as an alternative in an 'or' list
 '_' match if the linked words exist in the given order and with no more than
     two intervening words. <br>
 See the examples above for details of usage.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="setMatchingOptions(java.lang.String)"><!-- --></A><H3>
setMatchingOptions</H3>
<PRE>
public void <B>setMatchingOptions</B>(java.lang.String&nbsp;matchingOptions)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setResponse(java.lang.String)"><!-- --></A><H3>
setResponse</H3>
<PRE>
public void <B>setResponse</B>(java.lang.String&nbsp;response)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="match(java.lang.String, java.lang.String)"><!-- --></A><H3>
match</H3>
<PRE>
public boolean <B>match</B>(java.lang.String&nbsp;matchingOptions,
                     java.lang.String&nbsp;pattern)</PRE>
<DL>
<DD>match checks the response provided against an established pattern using the
 matching options and special characters specified
 
 match works on whole reply
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="match(java.lang.String)"><!-- --></A><H3>
match</H3>
<PRE>
public boolean <B>match</B>(java.lang.String&nbsp;pattern)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="splitAndMatch(java.lang.String)"><!-- --></A><H3>
splitAndMatch</H3>
<PRE>
public boolean <B>splitAndMatch</B>(java.lang.String&nbsp;pattern)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../om/helper/NullQuestion.html" title="class in om.helper"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../om/helper/QEngineConfig.html" title="interface in om.helper"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?om/helper/PMatch.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PMatch.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
